# 实现文档3：DNS消息解析实现

本章详细阐述了DNS消息的编码（构建）和解码（解析）过程，这是项目中最注重细节和二进制操作的部分。所有实现都严格遵循RFC1035第4节中定义的格式。

我们将使用`java.nio.ByteBuffer`来高效地处理底层的字节操作。

## 3.1 消息解码 (`MessageParser.java`)

解码器（Parser）负责将从网络接收到的`byte[]`转换为`Message`对象。

### 3.1.1 解码流程

```java
public class MessageParser {
    public Message parse(byte[] data) {
        ByteBuffer buffer = ByteBuffer.wrap(data);
        Message message = new Message();

        // 1. 解析头部
        message.setHeader(parseHeader(buffer));

        // 2. 解析问题部分
        List<Question> questions = new ArrayList<>();
        for (int i = 0; i < message.getHeader().getQdcount(); i++) {
            questions.add(parseQuestion(buffer));
        }
        message.setQuestions(questions);

        // 3. 解析回答、权威、附加部分
        message.setAnswers(parseRecords(buffer, message.getHeader().getAncount()));
        message.setAuthorities(parseRecords(buffer, message.getHeader().getNscount()));
        message.setAdditionals(parseRecords(buffer, message.getHeader().getArcount()));

        return message;
    }
}
```

### 3.1.2 域名解析（包含指针压缩）
域名解析是整个过程中最复杂的部分，因为它必须支持RFC1035中定义的指针压缩方案。

```java
private String parseDomainName(ByteBuffer buffer) {
    StringBuilder name = new StringBuilder();
    while (buffer.hasRemaining()) {
        int length = buffer.get() & 0xFF;
        if (length == 0) {
            // 域名以0x00结尾
            break;
        }

        // 判断是否为指针 (前两位是11)
        if ((length & 0xC0) == 0xC0) {
            int offset = ((length & 0x3F) << 8) | (buffer.get() & 0xFF);
            // 保存当前位置，跳转到指针位置读取，然后恢复
            int currentPos = buffer.position();
            buffer.position(offset);
            name.append(parseDomainName(buffer));
            buffer.position(currentPos);
            break; // 指针是域名的结尾
        } else {
            // 普通标签
            byte[] label = new byte[length];
            buffer.get(label);
            name.append(new String(label)).append(".");
        }
    }
    // 移除末尾多余的点
    if (name.length() > 0) {
        name.setLength(name.length() - 1);
    }
    return name.toString();
}
```

### 3.1.3 资源记录解析 (`ResourceRecord`)
解析资源记录时，`RDATA`部分的处理取决于记录的类型(`type`)。

```java
private ResourceRecord parseResourceRecord(ByteBuffer buffer) {
    String name = parseDomainName(buffer);
    int type = buffer.getShort() & 0xFFFF;
    int clazz = buffer.getShort() & 0xFFFF;
    long ttl = buffer.getInt() & 0xFFFFFFFFL;
    int rdlength = buffer.getShort() & 0xFFFF;

    byte[] rdata = new byte[rdlength];
    buffer.get(rdata);
    
    // 注意：这里的rdata是原始字节。
    // 在实际使用时（例如，获取A记录的IP地址），
    // 需要根据type进一步解析rdata。
    // 例: if (type == 1) { ip = InetAddress.getByAddress(rdata); }
    
    return new ResourceRecord(name, type, clazz, ttl, rdlength, rdata);
}
```

## 3.2 消息编码 (`MessageBuilder.java`)

编码器（Builder）负责将`Message`对象转换为`byte[]`，以便通过网络发送。

### 3.2.1 编码流程
```java
public class MessageBuilder {
    public byte[] build(Message message) {
        ByteBuffer buffer = ByteBuffer.allocate(512); // 标准UDP包大小
        
        // 1. 构建头部 (此时计数部分先用占位符)
        buildHeader(buffer, message.getHeader());

        // 2. 构建问题部分
        // ...

        // 3. 构建RR部分（回答、权威、附加）
        // ...

        // 4. (可选) 实现域名压缩
        // ...

        // 5. 回填头部的计数器

        buffer.flip();
        byte[] result = new byte[buffer.remaining()];
        buffer.get(result);
        return result;
    }
}
```

### 3.2.2 域名编码（包含指针压缩）
编码时的域名压缩比解码时更复杂。需要维护一个`Map<String, Integer>`来记录每个域名标签出现的位置，以便后续的标签可以被替换为指针。

```java
private void buildDomainName(ByteBuffer buffer, String name, Map<String, Integer> compressionMap) {
    String[] labels = name.split("\\.");
    for (String label : labels) {
        if (compressionMap.containsKey(name)) {
            // 发现可压缩部分，写入指针
            int offset = compressionMap.get(name);
            buffer.putShort((short) (0xC000 | offset));
            return; // 指针标志着结束
        } else {
            // 将当前域名和位置存入map
            compressionMap.put(name, buffer.position());
            buffer.put((byte) label.length());
            buffer.put(label.getBytes());
        }
        // 准备处理下一个子域名
        name = name.substring(label.length() + (name.endsWith(".") ? 0 : 1));
    }
    buffer.put((byte) 0); // 域名结尾
}
```

这个过程是递归的，需要精心设计以获得最佳的压缩率。

## 3.3 总结

DNS消息的解析和构建是字节级别的精细操作，特别需要注意以下几点：
- **字节序**：DNS协议使用大端字节序（Big-Endian），`ByteBuffer`默认就是大端。
- **无符号数**：Java没有原生无符号类型，需要用更大的类型来存储，并通过位运算`& 0xFF`、`& 0xFFFF`等来确保正确的值。
- **域名压缩**：解码和编码时都必须正确处理，是实现中的难点和重点。
- **RDATA处理**：RDATA的解析是与记录类型相关的，需要在更高层（如解析器逻辑中）进行。 