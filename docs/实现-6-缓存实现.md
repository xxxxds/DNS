# 实现文档6：DNS缓存实现

本章详细描述了项目中DNS缓存的设计与实现。一个高效的缓存系统是高性能DNS服务的基石，它直接关系到查询响应速度和网络资源的利用率。

## 6.1 缓存目标

1.  **降低延迟**：对于重复的查询，直接从内存返回结果，避免了完整的递归解析过程。
2.  **减少网络流量**：减少对上游DNS服务器的请求，节省带宽。
3.  **提高可用性**：在上游服务器短暂不可用时，仍能为已缓存的域名提供解析。

## 6.2 缓存数据结构

我们将实现一个基于内存的缓存，`InMemoryDnsCache`，它实现了`DnsCache`接口。核心数据结构将是一个`ConcurrentHashMap`，以确保线程安全。

```java
// In com.dns.cache.InMemoryDnsCache
private final ConcurrentHashMap<String, CacheEntry> cache;
```

### 6.2.1 缓存键 (`Cache Key`)
缓存的键（Key）将由查询的域名（qname）和类型（qtype）组合而成，格式为 `"qname:qtype"`。这确保了对同一域名的不同类型查询（如`example.com`的`A`记录和`MX`记录）可以被独立缓存。

### 6.2.2 缓存条目 (`CacheEntry`)
仅仅存储`List<ResourceRecord>`是不够的，我们还需要存储TTL信息，以便判断缓存是否过期。因此，我们创建一个内部类`CacheEntry`。

```java
private static class CacheEntry {
    private final List<ResourceRecord> records;
    private final long expiryTime; // 缓存的绝对过期时间戳 (System.currentTimeMillis() + TTL * 1000)

    public CacheEntry(List<ResourceRecord> records) {
        this.records = records;
        // 使用记录中最小的TTL作为整个条目的TTL
        long minTtl = records.stream()
                              .mapToLong(ResourceRecord::getTtl)
                              .min()
                              .orElse(60); // 默认60秒
        this.expiryTime = System.currentTimeMillis() + minTtl * 1000;
    }

    public boolean isExpired() {
        return System.currentTimeMillis() > expiryTime;
    }
}
```

## 6.3 缓存操作实现

### 6.3.1 存入缓存 (`put`)
当`RecursiveResolver`获得一个最终的、可信的DNS记录列表后，它会调用`put`方法。

```java
// In com.dns.cache.InMemoryDnsCache

public void put(Question question, List<ResourceRecord> records) {
    if (records == null || records.isEmpty()) {
        // 可以考虑实现负缓存
        return;
    }
    String key = generateKey(question.getQname(), question.getQtype());
    CacheEntry entry = new CacheEntry(records);
    cache.put(key, entry);
}
```

### 6.3.2 读取缓存 (`get`)
`get`方法在检查键是否存在的同时，必须验证缓存条目是否已过期。

```java
// In com.dns.cache.InMemoryDnsCache

public Optional<List<ResourceRecord>> get(Question question) {
    String key = generateKey(question.getQname(), question.getQtype());
    CacheEntry entry = cache.get(key);

    if (entry == null) {
        return Optional.empty(); // 未命中
    }

    if (entry.isExpired()) {
        cache.remove(key); // 惰性删除过期条目
        return Optional.empty(); // 已过期，视为未命中
    }

    return Optional.of(entry.getRecords());
}
```

## 6.4 缓存淘汰策略

我们的主要淘汰策略是基于**TTL的被动淘汰**（也称惰性删除）。当一个条目被访问时，我们才检查它是否过期。如果过期，就将其删除。

为了防止缓存无限增长（例如，存储了大量长TTL的记录），还需要一个**主动清理机制**。

### 6.4.1 主动清理线程
可以启动一个低优先级的后台线程，定期扫描缓存，移除所有已过期的条目。

```java
private void startCleanupThread() {
    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    // 每10分钟扫描一次
    scheduler.scheduleAtFixedRate(() -> {
        cache.entrySet().removeIf(entry -> entry.getValue().isExpired());
    }, 10, 10, TimeUnit.MINUTES);
}
```
此外，也可以设置一个缓存最大条目数。当缓存达到上限时，可以采用**LRU（最近最少使用）**或**LFU（最不经常使用）**等算法来淘汰数据。对于本项目的初始实现，基于TTL的清理已经足够。

## 6.5 负缓存 (Negative Caching)

负缓存是指缓存那些"域名不存在"（NXDOMAIN）或"记录类型不存在"的响应。这对于防止对无效域名的重复递归查询非常重要。

-   **实现方式**：可以创建一个特殊的`CacheEntry`，或者在`CacheEntry`中增加一个标志位来表示这是一个负缓存条目。当`RecursiveResolver`收到一个NXDOMAIN响应时，就向缓存中`put`一个负缓存条目。
-   **TTL**：负缓存的TTL通常由权威服务器的SOA记录中的`minimum`字段决定，一般比正常记录的TTL短。 